<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Star Dodge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0f172a;
            overflow: hidden;
            font-family: 'Press+Start+2P', cursive;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-bounce-in {
            animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
    </style>

<link rel="stylesheet" href="/index.css">
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
  <script type="module" crossorigin src="/assets/index-B5Qt9EMX.js"></script>
</head>
<body class="bg-slate-900 w-screen h-screen flex items-center justify-center overflow-hidden">

    <!-- App Container -->
    <div id="app" class="relative w-full h-full flex items-center justify-center overflow-hidden">
        
        <!-- Background Decor (Static) -->
        <div class="absolute inset-0 pointer-events-none opacity-20 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-blue-500/20 via-transparent to-transparent"></div>

        <!-- Start Menu -->
        <div id="menu-screen" class="z-20 flex flex-col items-center justify-center space-y-8 animate-fade-in text-center p-6">
            <h1 class="text-4xl md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-fuchsia-500 leading-tight drop-shadow-lg">
                NEON STAR<br/>DODGE
            </h1>
            <div id="menu-highscore" class="text-blue-300 text-sm md:text-lg animate-pulse">
                HIGH SCORE: 0
            </div>
            <button id="start-btn" class="px-8 py-4 bg-transparent border-4 border-blue-500 text-blue-500 hover:bg-blue-500 hover:text-white transition-all duration-300 transform hover:scale-110 active:scale-95 text-xl">
                START GAME
            </button>
            <div class="text-slate-500 text-[10px] md:text-xs max-w-xs leading-relaxed space-y-2 uppercase">
                <p>Move mouse or touch to dodge red blocks</p>
                <p>Collect yellow stars for bonus points</p>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute top-8 left-0 right-0 text-center pointer-events-none z-10">
            <div id="current-score" class="text-white text-2xl drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)]">
                SCORE: 0
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden z-20 flex flex-col items-center justify-center space-y-8 animate-bounce-in text-center p-8 bg-slate-900/90 rounded-3xl border-4 border-fuchsia-500 shadow-[0_0_50px_rgba(217,70,239,0.3)]">
            <h2 class="text-4xl text-fuchsia-500 leading-tight">GAME OVER</h2>
            <div class="space-y-4">
                <div id="final-score" class="text-white text-2xl">FINAL SCORE: 0</div>
                <div id="new-record" class="hidden text-yellow-400 text-sm animate-pulse">★ NEW HIGH SCORE ★</div>
                <div id="best-score" class="text-slate-400 text-sm">BEST: 0</div>
            </div>
            <button id="restart-btn" class="px-8 py-4 bg-fuchsia-600 text-white rounded-lg hover:bg-fuchsia-500 transition-all duration-300 transform hover:scale-110 active:scale-95 text-xl">
                PLAY AGAIN
            </button>
        </div>

        <!-- Gameplay Canvas -->
        <canvas id="game-canvas" class="hidden absolute inset-0 w-full h-full"></canvas>
    </div>

    <script>
        // Constants from original code
        const PLAYER_SIZE = 40;
        const OBSTACLE_MIN_SIZE = 20;
        const OBSTACLE_MAX_SIZE = 50;
        const STAR_SIZE = 20;
        const SPAWN_RATE = 0.02;
        const STAR_SPAWN_RATE = 0.005;
        const INITIAL_SPEED = 3;
        const SPEED_INCREMENT = 0.0005;

        // Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const hud = document.getElementById('hud');
        const gameOverScreen = document.getElementById('game-over-screen');
        const currentScoreEl = document.getElementById('current-score');
        const finalScoreEl = document.getElementById('final-score');
        const bestScoreEl = document.getElementById('best-score');
        const menuHighScoreEl = document.getElementById('menu-highscore');
        const newRecordEl = document.getElementById('new-record');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // State
        let gameState = 'MENU';
        let highScore = parseInt(localStorage.getItem('neon-star-highscore')) || 0;
        let score = 0;
        let speedMultiplier = 1;
        let animationFrameId;

        const player = {
            x: 0,
            y: 0,
            width: PLAYER_SIZE,
            height: PLAYER_SIZE,
            speed: 0.15, // Smooth lerp speed
            targetX: 0,
            color: '#38bdf8'
        };

        let obstacles = [];
        let stars = [];

        // Initialize UI
        menuHighScoreEl.textContent = `HIGH SCORE: ${highScore}`;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Update player Y based on new height
            player.y = canvas.height - PLAYER_SIZE - 60;
            // Center player initially or on resize if in menu
            if (gameState === 'MENU') {
                player.x = canvas.width / 2 - PLAYER_SIZE / 2;
                player.targetX = player.x;
            }
        }

        function spawnObstacle() {
            const size = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
            obstacles.push({
                x: Math.random() * (canvas.width - size),
                y: -size,
                width: size,
                height: size,
                speed: (Math.random() * 2 + INITIAL_SPEED) * speedMultiplier,
                color: '#ef4444'
            });
        }

        function spawnStar() {
            stars.push({
                x: Math.random() * (canvas.width - STAR_SIZE),
                y: -STAR_SIZE,
                width: STAR_SIZE,
                height: STAR_SIZE,
                speed: (Math.random() * 1 + INITIAL_SPEED) * speedMultiplier,
                color: '#ffb703'
            });
        }

        function update() {
            // Player horizontal lerp movement
            player.x += (player.targetX - player.x) * player.speed;
            
            // Bounds check
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;

            // Increase difficulty
            speedMultiplier += SPEED_INCREMENT;

            // Spawning
            if (Math.random() < SPAWN_RATE) spawnObstacle();
            if (Math.random() < STAR_SPAWN_RATE) spawnStar();

            // Obstacles logic
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += obs.speed;

                // Collision Detection
                if (player.x < obs.x + obs.width &&
                    player.x + player.width > obs.x &&
                    player.y < obs.y + obs.height &&
                    player.y + player.height > obs.y) {
                    endGame();
                    return;
                }

                // Cleanup and Scoring
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1);
                    score += 1;
                    currentScoreEl.textContent = `SCORE: ${score}`;
                }
            }

            // Stars logic
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                star.y += star.speed;

                // Collection
                if (player.x < star.x + star.width &&
                    player.x + player.width > star.x &&
                    player.y < star.y + star.height &&
                    player.y + player.height > star.y) {
                    stars.splice(i, 1);
                    score += 50;
                    currentScoreEl.textContent = `SCORE: ${score}`;
                    continue;
                }

                // Cleanup
                if (star.y > canvas.height) {
                    stars.splice(i, 1);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Background Grid
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            const spacing = 60;
            for (let x = 0; x <= canvas.width; x += spacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += spacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // 2. Draw Stars
            ctx.shadowBlur = 15;
            for (const star of stars) {
                ctx.fillStyle = star.color;
                ctx.shadowColor = star.color;
                ctx.beginPath();
                ctx.arc(star.x + star.width/2, star.y + star.height/2, star.width/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // 3. Draw Obstacles
            ctx.shadowBlur = 10;
            for (const obs of obstacles) {
                ctx.fillStyle = obs.color;
                ctx.shadowColor = obs.color;
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }

            // 4. Draw Player
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            ctx.shadowBlur = 0; // Reset shadow for next frame
        }

        function gameLoop() {
            if (gameState !== 'PLAYING') return;
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            speedMultiplier = 1;
            obstacles = [];
            stars = [];
            currentScoreEl.textContent = `SCORE: 0`;
            
            menuScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            canvas.classList.remove('hidden');
            hud.classList.remove('hidden');
            
            resize();
            gameLoop();
        }

        function endGame() {
            gameState = 'GAME_OVER';
            cancelAnimationFrame(animationFrameId);
            
            const isNewHigh = score > highScore;
            if (isNewHigh) {
                highScore = score;
                localStorage.setItem('neon-star-highscore', highScore);
                newRecordEl.classList.remove('hidden');
            } else {
                newRecordEl.classList.add('hidden');
            }

            finalScoreEl.textContent = `FINAL SCORE: ${score}`;
            bestScoreEl.textContent = `BEST: ${highScore}`;
            menuHighScoreEl.textContent = `HIGH SCORE: ${highScore}`;

            hud.classList.add('hidden');
            canvas.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        // Input Handlers
        const handleInput = (clientX) => {
            player.targetX = clientX - player.width / 2;
        };

        window.addEventListener('mousemove', (e) => handleInput(e.clientX));
        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                handleInput(e.touches[0].clientX);
            }
        }, { passive: true });

        window.addEventListener('resize', resize);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);

        // Initial Layout
        resize();
    </script>
</body>
</html>
